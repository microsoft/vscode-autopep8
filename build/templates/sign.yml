# Template: Sign and validate VS Code extension artifacts
# Usage Example:
# - template: build/templates/sign.yml@self
#   parameters:
#     vsixName: autopep8.vsix
#     workingDirectory: $(Build.SourcesDirectory)
#     signType: real

parameters:
  - name: vsixName
    type: string
    default: autopep8.vsix
  - name: manifestName
    type: string
    default: extension.manifest
  - name: signatureName
    type: string
    default: extension.signature.p7s
  - name: workingDirectory
    type: string
    default: '$(Build.SourcesDirectory)'
  - name: signType
    type: string
    default: real
  - name: verifySignature
    type: boolean
    default: true
  - name: prepareRoot
    type: boolean
    default: true
  # vsceVersion parameter removed (always use @vscode/vsce@latest explicitly)

steps:
  - script: |
      npm install -g @vscode/vsce@latest
      echo "vsce version:"
      vsce --version
    displayName: Install & show vsce CLI

  - task: NuGetToolInstaller@1
    displayName: Install NuGet

  - task: NuGetCommand@2
    displayName: Restore signing packages
    inputs:
      command: restore
      restoreSolution: '$(Build.SourcesDirectory)/packages.config'
      restoreDirectory: '$(Build.SourcesDirectory)/packages'

  - task: PowerShell@2
    displayName: Pre-sign inspection
    inputs:
      targetType: inline
      script: |
        $wd = "${{ parameters.workingDirectory }}"
        $vsixName = "${{ parameters.vsixName }}"
        $manifestName = "${{ parameters.manifestName }}"
        $signatureName = "${{ parameters.signatureName }}"
        Write-Host "Pre-sign contents of working directory: $wd"
        Get-ChildItem -Recurse $wd | Select-Object FullName,Length | Format-Table -AutoSize
        $vsix = Join-Path $wd $vsixName
        if (!(Test-Path $vsix)) { Write-Error "VSIX missing: $vsix"; exit 1 }
        $manifest = Join-Path $wd $manifestName
        if (!(Test-Path $manifest)) { Write-Error "Manifest missing: $manifest"; exit 1 }
        $sig = Join-Path $wd $signatureName
        if (!(Test-Path $sig)) { Write-Warning "Signature placeholder missing (will attempt signing anyway)." }

  - ${{ if eq(parameters.prepareRoot, true) }}:
    - task: PowerShell@2
      displayName: Prepare root files for MicroBuild signing
      inputs:
        targetType: inline
        script: |
          $wd = "${{ parameters.workingDirectory }}"
          $root = "$(Build.SourcesDirectory)"
          $manifestName = "${{ parameters.manifestName }}"
          $signatureName = "${{ parameters.signatureName }}"
          $manifestSrc = Join-Path $wd $manifestName
          if (!(Test-Path $manifestSrc)) { Write-Error "Manifest not found in working directory: $manifestSrc"; exit 1 }
          $manifestDest = Join-Path $root $manifestName
          Copy-Item $manifestSrc $manifestDest -Force
          Write-Host "Copied manifest to root: $manifestDest"
          $sigSrc = Join-Path $wd $signatureName
          if (!(Test-Path $sigSrc)) {
            Write-Host "Signature placeholder missing; creating from manifest." 
            Copy-Item $manifestDest (Join-Path $wd $signatureName) -Force
            $sigSrc = Join-Path $wd $signatureName
          }
            $sigDest = Join-Path $root $signatureName
            Copy-Item $sigSrc $sigDest -Force
            Write-Host "Copied signature placeholder to root: $sigDest"
            Get-Item $manifestDest,$sigDest | Format-Table Name,Length -AutoSize

  - task: MSBuild@1
    displayName: Run signing (MSBuild)
    inputs:
      solution: '$(Build.SourcesDirectory)/sign.proj'
      msbuildArguments: '/verbosity:minimal /p:SignType=${{ parameters.signType }}'

  - task: PowerShell@2
    displayName: Copy signed signature back to working directory
    inputs:
      targetType: inline
      script: |
        $wd = "${{ parameters.workingDirectory }}"
        $root = "$(Build.SourcesDirectory)"
        $signatureName = "${{ parameters.signatureName }}"
        $rootSig = Join-Path $root $signatureName
        if (!(Test-Path $rootSig)) { Write-Error "Signed signature not found at root: $rootSig"; exit 1 }
        $wdSig = Join-Path $wd $signatureName
        Copy-Item $rootSig $wdSig -Force
        Write-Host "Copied signed signature to working directory: $wdSig"
        Get-Item $rootSig,$wdSig | Select-Object FullName,Length,LastWriteTime | Format-Table -AutoSize

  - task: PowerShell@2
    displayName: Post-sign inspection
    inputs:
      targetType: inline
      script: |
        $wd = "${{ parameters.workingDirectory }}"
        $signatureName = "${{ parameters.signatureName }}"
        Write-Host "Post-sign file listing:"
        Get-ChildItem $wd -File | Select-Object Name,Length | Format-Table -AutoSize
        $sig = Join-Path $wd $signatureName
        if (Test-Path $sig) {
          Write-Host "Signature file present: $sig"
        } else {
          Write-Warning "Signature file NOT present after signing step."; exit 0
        }

  - task: PowerShell@2
    displayName: Validate signature differs from manifest (hash check)
    inputs:
      targetType: inline
      script: |
        $wd = "${{ parameters.workingDirectory }}"
        $manifest = Join-Path $wd "${{ parameters.manifestName }}"
        $signature = Join-Path $wd "${{ parameters.signatureName }}"
        if (!(Test-Path $manifest)) { Write-Error "Manifest missing for hash comparison: $manifest"; exit 1 }
        if (!(Test-Path $signature)) { Write-Error "Signature missing for hash comparison: $signature"; exit 1 }
        $manifestHash = (Get-FileHash -Algorithm SHA256 $manifest).Hash
        $signatureHash = (Get-FileHash -Algorithm SHA256 $signature).Hash
        Write-Host "Manifest SHA256 : $manifestHash"
        Write-Host "Signature SHA256: $signatureHash"
        if ($manifestHash -eq $signatureHash) {
          Write-Error "Signature file is identical to manifest (placeholder detected). Failing build."; exit 1
        } else {
          Write-Host "Hashes differ ✅ (signature not a direct copy of manifest)"
        }

  - ${{ if eq(parameters.verifySignature, true) }}:
    - task: PowerShell@2
      displayName: Verify VSIX signature
      inputs:
        targetType: inline
        script: |
          $wd = "${{ parameters.workingDirectory }}"
          $vsix       = Join-Path $wd "${{ parameters.vsixName }}"
          $manifest   = Join-Path $wd "${{ parameters.manifestName }}"
          $signature  = Join-Path $wd "${{ parameters.signatureName }}"
          Write-Host "Verifying signature:"
          Write-Host "  packagePath  : $vsix"
          Write-Host "  manifestPath : $manifest"
          Write-Host "  signaturePath: $signature"
          if (!(Test-Path $vsix)) { Write-Error "Missing VSIX: $vsix"; exit 1 }
          if (!(Test-Path $manifest)) { Write-Error "Missing manifest: $manifest"; exit 1 }
          if (!(Test-Path $signature)) { Write-Error "Missing signature file: $signature"; exit 1 }
          npx @vscode/vsce@latest verify-signature --packagePath "$vsix" --manifestPath "$manifest" --signaturePath "$signature"
          if ($LASTEXITCODE -ne 0) {
            Write-Error "vsce verify-signature failed with exit code $LASTEXITCODE"
            exit $LASTEXITCODE
          } else {
            Write-Host "vsce verify-signature succeeded ✅"
          }
